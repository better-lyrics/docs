---
import DocsLayout from '../../layouts/DocsLayout.astro';
---

<DocsLayout title="Response format">
  <p>
    The default TTML provider returns lyrics in Timed Text Markup Language format,
    providing syllable-level timing data for precise synchronization.
  </p>

  <h2>Response structure</h2>
  <pre><code class="language-json">{`{
  "ttml": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>...",
  "score": 95
}`}</code></pre>

  <table>
    <thead>
      <tr>
        <th>Field</th>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>ttml</code></td>
        <td>string</td>
        <td>The full TTML XML document as a string</td>
      </tr>
      <tr>
        <td><code>score</code></td>
        <td>number</td>
        <td>Match confidence score (0-100). Higher is better.</td>
      </tr>
    </tbody>
  </table>

  <h2>TTML structure</h2>
  <p>
    The TTML document contains timing information for each word. For the full specification, see the <a href="https://www.w3.org/TR/2018/REC-ttml2-20181108/" target="_blank" rel="noopener">W3C TTML2 Recommendation</a>.
  </p>
  <p class="note">Note: The example below is formatted for readability. Actual responses are not formatted - see the whitespace warning <a href="#important-whitespace-handling">here</a>.</p>

  <pre><code class="language-xml">{`<?xml version="1.0" encoding="UTF-8"?>
<tt xmlns="http://www.w3.org/ns/ttml">
  <body>
    <div>
      <p begin="00:00:18.234" end="00:00:21.891">
        <span begin="00:00:18.234" end="00:00:18.567">The </span>
        <span begin="00:00:18.567" end="00:00:18.901">club </span>
        <span begin="00:00:18.901" end="00:00:19.234">isn't </span>
        <span begin="00:00:19.234" end="00:00:19.568">the </span>
        <span begin="00:00:19.568" end="00:00:19.901">best </span>
        <span begin="00:00:19.901" end="00:00:20.234">place </span>
        <span begin="00:00:20.234" end="00:00:20.568">to </span>
        <span begin="00:00:20.568" end="00:00:20.901">find </span>
        <span begin="00:00:20.901" end="00:00:21.234">a </span>
        <span begin="00:00:21.234" end="00:00:21.891">lover</span>
      </p>
    </div>
  </body>
</tt>`}</code></pre>

  <h2>Key elements</h2>

  <h3><code>&lt;p&gt;</code> - Line element</h3>
  <p>Each <code>&lt;p&gt;</code> represents a line of lyrics:</p>
  <ul>
    <li><code>begin</code> - Start time of the line</li>
    <li><code>end</code> - End time of the line</li>
  </ul>

  <h3><code>&lt;span&gt;</code> - Word element</h3>
  <p>Each <code>&lt;span&gt;</code> within a line represents a word:</p>
  <ul>
    <li><code>begin</code> - Start time of the word</li>
    <li><code>end</code> - End time of the word</li>
    <li>Text content is the word itself (including trailing spaces)</li>
  </ul>

  <h2>Important: whitespace handling</h2>
  <div class="warning-box">
    <p>
      <strong>Do not format or pretty-print the TTML response.</strong>
    </p>
    <p>
      The response uses whitespace between <code>&lt;span&gt;</code> elements to represent spaces
      between syllables/words. This whitespace is not enclosed in tags. If you format the XML
      (e.g., with a pretty-printer), these critical whitespaces will be lost, breaking the
      syllable synchronization.
    </p>
    <p>
      Always preserve the original string exactly as received. When parsing, use the raw
      <code>textContent</code> of each span, which includes the intended whitespace.
    </p>
  </div>

  <h2>Time format</h2>
  <p>Times can appear in two formats:</p>
  <ul>
    <li><code>HH:MM:SS.mmm</code> - e.g., <code>00:01:30.500</code> = 90.5 seconds</li>
    <li><code>M:SS.mmm</code> - e.g., <code>1:16.656</code> = 76.656 seconds</li>
  </ul>
  <p>Your parser should handle both formats. The JavaScript example below demonstrates this.</p>

  <h2>Parsing example (JavaScript)</h2>
  <pre><code class="language-javascript">{`function parseTTML(ttmlString) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(ttmlString, 'text/xml');
  const lines = [];

  doc.querySelectorAll('p').forEach(p => {
    const agent = p.getAttribute('ttm:agent'); // Agent ID as defined in metadata (v1, v2, v1000, etc.)
    const words = [];

    // Recursively collect spans, tracking background vocal context
    function collectSpans(element, isBackground = false) {
      element.childNodes.forEach(node => {
        if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'span') {
          const isBg = isBackground || node.getAttribute('ttm:role') === 'x-bg';
          const begin = node.getAttribute('begin');

          if (begin) {
            // This is a timed span (word)
            words.push({
              text: node.textContent,
              begin: parseTime(begin),
              end: parseTime(node.getAttribute('end')),
              isBackground: isBg
            });
          } else {
            // This is a wrapper span, recurse into it
            collectSpans(node, isBg);
          }
        }
      });
    }

    collectSpans(p);

    lines.push({
      begin: parseTime(p.getAttribute('begin')),
      end: parseTime(p.getAttribute('end')),
      agent,
      words
    });
  });

  return lines;
}

function parseTime(timeStr) {
  // Handles "HH:MM:SS.mmm", "M:SS.mmm", "SS.mmm"
  const parts = timeStr.split(':');
  let seconds = 0;

  if (parts.length === 3) {
    seconds = parseInt(parts[0]) * 3600 +
              parseInt(parts[1]) * 60 +
              parseFloat(parts[2]);
  } else if (parts.length === 2) {
    seconds = parseInt(parts[0]) * 60 +
              parseFloat(parts[1]);
  } else {
    seconds = parseFloat(parts[0]);
  }

  return Math.round(seconds * 1000); // Return milliseconds
}`}</code></pre>

  <h2>RTL language support</h2>
  <p>
    For right-to-left languages (Arabic, Hebrew, Persian, etc.), the TTML document
    includes language attributes:
  </p>
  <pre><code class="language-xml">{`<tt xml:lang="ar" xmlns="http://www.w3.org/ns/ttml">
  ...
</tt>`}</code></pre>
  <p>
    Check the <code>xml:lang</code> attribute to determine text direction.
    Common RTL language codes: <code>ar</code>, <code>he</code>, <code>fa</code>, <code>ur</code>.
  </p>

  <h2>Multiple speakers</h2>
  <p>
    Songs with multiple vocalists use the <code>ttm:agent</code> attribute on <code>&lt;p&gt;</code>
    elements to identify which speaker is singing each line:
  </p>
  <pre><code class="language-xml">{`<p ttm:agent="v1" begin="0:05.123" end="0:08.456">
  <span begin="0:05.123" end="0:06.789">First </span>
  <span begin="0:06.789" end="0:08.456">vocalist</span>
</p>
<p ttm:agent="v2" begin="0:08.456" end="0:11.789">
  <span begin="0:08.456" end="0:10.123">Second </span>
  <span begin="0:10.123" end="0:11.789">vocalist</span>
</p>`}</code></pre>
  <p>
    Agent IDs are defined in the TTML metadata header:
  </p>
  <pre><code class="language-xml">{`<head>
  <metadata>
    <ttm:agent type="person" xml:id="v1">
      <ttm:name type="full">Artist Name</ttm:name>
    </ttm:agent>
    <ttm:agent type="person" xml:id="v2">
      <ttm:name type="full">Featured Artist</ttm:name>
    </ttm:agent>
  </metadata>
</head>`}</code></pre>
  <ul>
    <li>Agent IDs are defined via <code>&lt;ttm:agent xml:id="..."&gt;</code> in the metadata</li>
    <li>Most files use <code>v1</code>, <code>v2</code>, etc., but some use different IDs like <code>voice1</code></li>
    <li><code>v1000</code> (group) and <code>v2000</code> (other) conventionally indicate multiple speakers singing together</li>
    <li>Agent metadata may include speaker names via <code>&lt;ttm:name&gt;</code></li>
    <li>The <code>type</code> attribute must be one of: <code>person</code>, <code>character</code>, <code>group</code>, <code>organization</code>, or <code>other</code></li>
  </ul>

  <h2>Background vocals</h2>
  <p>
    Background vocals within a line are wrapped in a <code>&lt;span&gt;</code> with
    <code>ttm:role="x-bg"</code>:
  </p>
  <pre><code class="language-xml">{`<p ttm:agent="v1" begin="0:15.000" end="0:20.000">
  <span begin="0:15.000" end="0:17.500">Lead lyrics </span>
  <span ttm:role="x-bg">
    <span begin="0:17.500" end="0:20.000">background vocals</span>
  </span>
</p>`}</code></pre>

  <h2>Transliterations</h2>
  <p>
    Some TTML responses include synced transliterations (e.g., romanized Japanese lyrics).
    These are stored in the metadata header under <code>&lt;transliterations&gt;</code>:
  </p>
  <pre><code class="language-xml">{`<head>
  <metadata>
    <transliterations>
      <transliteration xml:lang="ja-Latn">
        <text for="L10">
          <span begin="1:03.557" end="1:04.868">mayonaka no</span>
          <span begin="1:04.868" end="1:05.457">doa o</span>
          <span begin="1:05.457" end="1:05.930">tata</span>
          <span begin="1:05.930" end="1:07.907">ki</span>
        </text>
      </transliteration>
    </transliterations>
  </metadata>
</head>`}</code></pre>
  <ul>
    <li>The <code>xml:lang</code> attribute specifies the target script (e.g., <code>ja-Latn</code> for Japanese romanization)</li>
    <li>Each <code>&lt;text for="..."&gt;</code> references a line by its <code>itunes:key</code> attribute</li>
    <li>Contains timed <code>&lt;span&gt;</code> elements, same as the main lyrics</li>
    <li>Note: Some transliterations have punctuation (like <code>)</code>) outside of <code>&lt;span&gt;</code> elements as raw text nodes</li>
  </ul>

  <h2>Response headers</h2>
  <p>Additional context is provided via response headers:</p>
  <table>
    <thead>
      <tr>
        <th>Header</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>X-Cache-Status</code></td>
        <td>Whether response came from cache (HIT, MISS, etc.)</td>
      </tr>
      <tr>
        <td><code>X-Provider</code></td>
        <td>Which provider served the response</td>
      </tr>
      <tr>
        <td><code>X-RateLimit-Type</code></td>
        <td>Current rate limit tier</td>
      </tr>
    </tbody>
  </table>
</DocsLayout>

<style>
  .note {
    font-size: 0.875rem;
    color: var(--text-muted);
    font-style: italic;
  }

  .warning-box {
    background-color: rgba(245, 158, 11, 0.1);
    border: 1px solid rgba(245, 158, 11, 0.3);
    border-radius: var(--radius-lg);
    padding: var(--space-4);
    margin: var(--space-4) 0;
  }

  .warning-box p {
    margin: 0;
    font-size: 0.9375rem;
  }

  .warning-box p + p {
    margin-top: var(--space-3);
  }

  .warning-box strong {
    color: var(--warning);
  }
</style>
